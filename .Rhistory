"umap","anocva","readxl",
"lavaan","mediation","factoextra")
for (pkg in pkg_list){
usethis::use_package(pkg)
}
# Add dependencies
pkg_list = c("cluster","dplyr",
"Rtsne","ggplot2","umap",
"anocva","readxl","dplyr",
"ggpubr","naniar", "lubridate",
"survival","ISLR","caret","qqman",
"scatterplot3d","magrittr",
"knitr","ggridges","viridis",
"ggpubr","GGally","reshape2",
"plotly","heatmaply","ggcorrplot",
"umap","anocva","readxl",
"lavaan","mediation","factoextra")
for (pkg in pkg_list){
usethis::use_package(pkg)
}
usethis::use_vignette("autoclust")
usethis::use_roxygen_md()
library(roxygen2)
roxygen2::roxygenise()
?compute_dissimilarity_matrix
# list dependencies
pkg_list = c("cluster","dplyr",
"Rtsne","ggplot2","umap",
"anocva","readxl","dplyr",
"ggpubr","naniar", "lubridate",
"survival","ISLR","caret","qqman",
"scatterplot3d","magrittr",
"knitr","ggridges","viridis",
"ggpubr","GGally","reshape2",
"plotly","heatmaply","ggcorrplot",
"umap","anocva","readxl",
"lavaan","mediation","factoextra",
"pheatmap")
# Add them to DESCRIPTION
for (pkg in pkg_list){
usethis::use_package(pkg)
}
# list dependencies
pkg_list = c("cluster","dplyr",
"Rtsne","ggplot2","umap",
"anocva","readxl","dplyr",
"ggpubr","naniar", "lubridate",
"survival","ISLR","caret","qqman",
"scatterplot3d","magrittr",
"knitr","ggridges","viridis",
"ggpubr","GGally","reshape2",
"plotly","heatmaply","ggcorrplot",
"umap","anocva","readxl",
"lavaan","mediation","factoextra",
"pheatmap", "factoextra")
# Add them to DESCRIPTION
for (pkg in pkg_list){
usethis::use_package(pkg)
}
#' @param ndim Maximum number of clusters to consider for the silhouette plot.
#' @return A list containing the dissimilarity matrix, optionally the heatmap plot, and the silhouette plot if specified.
#' @examples
#' # Example of how to use the function
#' result <- compute_dissimilarity_matrix(x = autoant_dataset, metric = "gower")
#' result$dissimilarity_matrix  # Access the matrix
#' result$heatmap_plot  # Access the plot (if plot_dissim = TRUE)
#' result$silhouette_plot  # Access the silhouette plot (if sillplot = TRUE)
#'
#' @export
compute_dissimilarity_matrix <- function(x, metric = c("euclidean", "manhattan", "gower"), stand = FALSE,
plot_dissim = TRUE, plot_title = paste0(metric, " Dissimilarity Matrix"),
plot_title_size = 20, sillplot = TRUE, ndim = 10) {
# Calculate the dissimilarity matrix
x_disim <- daisy(x, metric = metric, stand = stand)
x_dissim_matrix <- as.matrix(x_disim)
# Initialize a list to store results
result <- list(dissimilarity_matrix = x_dissim_matrix)
# Optionally create a heatmap plot
if (plot_dissim) {
pheatmap_dissim <- factoextra::fviz_dist(x_disim) +
theme(axis.text = element_text(size = 9), plot.title = element_text(size = plot_title_size)) +
ggtitle(plot_title)
# Add the plot to the list
result$heatmap_plot <- pheatmap_dissim
}
# Plot silhouette if specified by user
if (sillplot) {
# Calculate silhouette widths for cluster sizes 2 to ndim
sil_width <- numeric(ndim)
for (i in 2:ndim) {
pam_fit <- pam(x_disim, diss = TRUE, k = i)
sil_width[i] <- pam_fit$silinfo$avg.width
}
# Create silhouette plot with ggplot2
sil_data <- data.frame(Clusters = as.integer(1:ndim), Avg_Silhouette_Width = sil_width)
sillplot <- ggplot(sil_data, aes(x = Clusters, y = Avg_Silhouette_Width)) +
geom_line() +
geom_point() +
labs(x = "Number of clusters", y = "Average Silhouette Width") +
theme_minimal()
# Add silhouette plot to the list
result$silhouette_plot <- sillplot
}
# Return the list containing the matrix and, if requested, the plots
return(result)
}
help(ggsave)
theme_line()
theme_bw()
library(ggplot2)
roxygen2::roxygenise()
pkgload::dev_help('compute_dissimilarity_matrix')
sil_data <- sil_data %>% slice_head(n = 1)
roxygen2::roxygenise()
pkgload::dev_help('plot_most_similar_dissimilar')
library(RColorBrewer)
library(randomcoloR)
distinctColorPalette(2)
usethis::use_package("randomcoloR")
usethis::use_package("Rtsne")
roxygen2::roxygenise()
pkgload::dev_help('compute_dissimilarity_matrix')
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
usethis::use_package(cluster)
usethis::use_package("cluster")
visualize_clusters <- function(x, pam_fit, df, id_col, umap_nneight = c(10L, 15L, 20L, 25L, 30L, 35L, 40L, 45L, 50L),
umap_min_dist = c(0.1, 0.25, 0.3, 0.5, 0.75, 0.99), point_size = 2, save_plots = FALSE, plot_outpath = "."){
# Make sure x is a dissimilarity matrix
if (class(x)[1] != "dissimilarity"){
stop("x object must be a dissimilarity matrix")
}
# Make different colors for clusters
num_clusters = length(unique(pam_fit$clustering))
cluster_colors = randomcoloR::distinctColorPalette(num_clusters)
names(cluster_colors) = unique(pam_fit$clustering)
# Make tsne plot
tsne <- Rtsne(x, is_distance=TRUE)
tsne_plot_data <- tsne$Y %>%
data.frame()%>%
setNames(c("tsne1","tsne2"))%>%
mutate(cluster=factor(pam_fit$clustering),
ID=df[[id_col]])
tsne_plot <- ggplot(data = tsne_plot_data, aes(x=tsne1,y=tsne2))+
geom_point(aes(color=cluster), alpha = 0.8, size = point_size) +
theme_linedraw()
# If save_plots TRUE save tsne plot
if (save_plots){
ggsave(filename = "tsne_dist.jpeg", plot = tsne_plot,
bg = "white", path = plot_outpath)
}
# Save results in a list
results <- list()
results$tnse_plot <- tsne_plot
# Make UMAP
umap_plots <- list()
for (neigh in umap_nneight) { # Loop over neighbor values
for (dist in umap_min_dist) { # Loop over distance values
message(sprintf("Computing UMAP for nneigh = %s, min_dist = %s", neigh, dist))
umap_coords <- run_custom_umap(x, neighbors = neigh, min_dist = dist)
ggplot_umap <- plot_custom_umap(umap_coords, pam_fit$clustering, neigh, dist, pt.size = point_size)
umap_plots[[as.character(neigh)]][[as.character(dist)]] <- ggplot_umap
if (save_plots){
ggsave(filename = sprintf("umap_neigh%s_dist%s.png", as.character(neigh), dist),
plot = ggplot_umap, bg = "white", path = plot_outpath)
}
}
}
results$umap_plots <- umap_plots
# Make line plot
# TODO
# Return results
return(results)
}
usethis::use_package("rstanarm")
groups <- as.character(unique(clinical_data_df[[outcome_var_colname]]))
help(element_text)
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
run_associations <- function(clinical_data_df, clinical_data_cols, outcome_var_colname = "subgroup",
adjust_by ="Age_dx + male.female_dx", family = binomial, link = "logit", plot = FALSE, y.axis.text.size = 12,
or.label.size = 3, ntop = 10, order = FALSE, adjust_p = FALSE, add_xylabs = FALSE, name_mapping = NULL,
xlim_min = -2.5, xlim_max = 2.5, x.axis.text.size = 8){
# Retrieve clinical manifestation names
if (is(clinical_data_cols, "numeric")){
clinical_manifestations = colnames(clinical_data)[clinical_data_cols] # Select the names of the columns that contain clinical manifestations.
} else {
clinical_manifestations = as.character(clinical_data_cols)
}
# Which columns should be factors?
factor_cols = c(clinical_manifestations, outcome_var_colname)
# Check which columns exist
#adjustment_vars <- unlist(strsplit(adjust_by, "\\+")) # Split by "+"
#adjustment_vars <- trimws(adjustment_vars) # Remove extra spaces
#required_vars <- unique(c(clinical_manifestations, outcome_var_colname, adjustment_vars))
#missing_required <- setdiff(required_vars, colnames(clinical_data_df))
#if (length(missing_required) > 0){
#  stop(sprintf("The following required variables are missing from the dataframe: %s", paste(missing_required, collapse = ", ")))
#}
# Remove rows with NA in any required columns
#n_before <- nrow(clinical_data_df)
#clinical_data_df <- clinical_data_df %>%
#  dplyr::filter(!if_any(all_of(required_vars), is.na))
#n_after <- nrow(clinical_data_df)
#n_removed <- n_before - n_after
#if (n_removed > 0){
#  message(sprintf("%d rows containing NA values were removed before model fitting.", n_removed))
#}
# Check that all columns involved as treated as factor (only for log regression)
if (identical(family, binomial)){
clinical_data_df[factor_cols] <- lapply(clinical_data_df[factor_cols], function(column) {
if (!is.factor(column)) {
return(as.factor(column))  # Convert to factor if not already a factor
} else {
return(column)  # Leave as is if already a factor
}
})
}
# Check that response outcome variable exists in dataset
if (!all(clinical_manifestations %in% colnames(clinical_data_df))){
missing_manifest <- clinical_manifestations[!clinical_manifestations %in% colnames(clinical_data_df)]
stop(sprintf("Clinical manifestation: %s not found in the dataframe.\n", missing_manifest))
}
# Check that the outcome variable is present in the dataframe
if (!outcome_var_colname %in% colnames(clinical_data_df)){
stop(sprintf("A column with outcome variable  %s was not found on dataframe", outcome_var_colname))
}
groups <- sort(as.character(unique(clinical_data_df[[outcome_var_colname]]))
# Add columns based on response variable membership
for (group in groups){
run_associations <- function(clinical_data_df, clinical_data_cols, outcome_var_colname = "subgroup",
adjust_by ="Age_dx + male.female_dx", family = binomial, link = "logit", plot = FALSE, y.axis.text.size = 12,
or.label.size = 3, ntop = 10, order = FALSE, adjust_p = FALSE, add_xylabs = FALSE, name_mapping = NULL,
xlim_min = -2.5, xlim_max = 2.5, x.axis.text.size = 8){
# Retrieve clinical manifestation names
if (is(clinical_data_cols, "numeric")){
clinical_manifestations = colnames(clinical_data)[clinical_data_cols] # Select the names of the columns that contain clinical manifestations.
} else {
clinical_manifestations = as.character(clinical_data_cols)
}
#print(c(clinical_manifestations, outcome_var_colname))
# Which columns should be factors?
factor_cols = c(clinical_manifestations, outcome_var_colname)
# Check that all columns involved as treated as factor (only for log regression)
if (identical(family, binomial)){
clinical_data_df[factor_cols] <- lapply(clinical_data_df[factor_cols], function(column) {
if (!is.factor(column)) {
return(as.factor(column))  # Convert to factor if not already a factor
} else {
return(column)  # Leave as is if already a factor
}
})
}
# Check that response outcome variable exists in dataset
if (!all(clinical_manifestations %in% colnames(clinical_data_df))){
missing_manifest <- clinical_manifestations[!clinical_manifestations %in% colnames(clinical_data_df)]
stop(sprintf("Clinical manifestation: %s not found in the dataframe.\n", missing_manifest))
}
# Check that the outcome variable is present in the dataframe
if (!outcome_var_colname %in% colnames(clinical_data_df)){
stop(sprintf("A column with outcome variable  %s was not found on dataframe", outcome_var_colname))
}
groups <- as.character(unique(clinical_data_df[[outcome_var_colname]]))
# Add columns based on response variable membership
for (group in groups){
clinical_data_df[[paste0(outcome_var_colname, group)]] = ifelse(clinical_data_df[[outcome_var_colname]] == group, 1, 0)
clinical_data_df[[paste0(outcome_var_colname, group)]] = as.factor(clinical_data_df[[paste0(outcome_var_colname, group)]])
}
model_ominibus_list <- list()
anova_list <- list()
summary_list <- list()
results_df <- data.frame()
# Iterate over all clinical manifestations
for (clin_manifest in clinical_manifestations){
for (group in groups){
# Create formula dynamically
try({
message(sprintf("Computing %s for %s", group, clin_manifest))
formula <- as.formula(sprintf("%s ~ %s%s + %s",
clin_manifest,
outcome_var_colname,
group,
adjust_by))
# Fit the model and store it in the list
model <- glm(formula,
family = family(link = link),
data = clinical_data_df)
message("Finished computing model!")
# Save model in list
model_ominibus_list[[group]][[clin_manifest]] <- model
# Extract OR, 95% CI, p-values, clinical manifest, and subgroup.
or_ci <- exp(cbind(OR = coef(model), confint(model)))
coeff_pval_df = data.frame(summary(model)$coefficients)
colnames(coeff_pval_df) <- c("Estimate", "Std_error", "z.value", "Pr>|z|")
or_ci_df <- as.data.frame(cbind(or_ci, coeff_pval_df))
or_ci_df$clinical_manifestation <- clin_manifest
or_ci_df$predictor <- rownames(or_ci_df)
or_ci_df[[outcome_var_colname]] <- group
# calculate anova
anova <- anova(model, test="Chisq")
anova_list[[group]][[clin_manifest]] <- anova
# Bind results to the main results data frame
results_df <- bind_rows(results_df, or_ci_df)
}, silent = TRUE)
}
}
# If order, arrange by pvalue
if (order){
results_df <- results_df %>%
arrange(`Pr>|z|`)
}
# Add results to list
results_list <- list(models = model_ominibus_list,
anova = anova_list,
summarized_results = results_df)
if (plot){
message("Making forest plot...")
forest <- make_forest_plot(results_df = results_df, ntop = ntop, clinical_manifestation = clinical_manifestation,
outcome_var_colname = outcome_var_colname, pt.size = 2, y.axis.text.size = y.axis.text.size,
x.axis.text.size = x.axis.text.size, name_mapping = name_mapping,
add_xylabs = add_xylabs, or.label.size = or.label.size, xlim_min = xlim_min, xlim_max = xlim_max, plot_title = "Clinical Associations")
results_list$forest_plot <- forest
results_list$df <- clinical_data_df
}
message("DONE!")
return(results_list)
}
make_forest_plot <- function(results_df, clinical_manifestation, outcome_var_colname,
clinical_manifestation_colname = "clinical_manifestation", ntop = NULL,
pt.size = 2, y.axis.text.size, x.axis.text.size, or.label.size, plot_title = "",
name_mapping = NULL, add_xylabs = FALSE, xlim_min = 0.5, xlim_max = 2.5) {
if (!is.null(ntop)){
# Select top results
top_results <- results_df[0:ntop, ] %>%
arrange(-OR)
} else {
top_results <- results_df
}
# Categorize results
top_results$category <- with(top_results, ifelse(`Pr>|z|` < 0.05, "Pval < 0.05", "Pval > 0.05"))
# Map names if provided by user
if (!is.null(name_mapping)) {
clinical_manifestation <- sapply(clinical_manifestation, function(col) name_mapping[[col]] %||% col)
# Rename clinical manifestation
top_results[[clinical_manifestation_colname]] <- sapply(top_results[[clinical_manifestation_colname]], function(clin) name_mapping[[clin]] %||% clin)
}
# Forest plot
forest <- ggplot(top_results, aes(x = OR, y = reorder(paste(clinical_manifestation, .data[[outcome_var_colname]], predictor, sep = " - "), OR))) +
geom_errorbarh(aes(xmin = `2.5 %`, xmax = `97.5 %`), height = 0.2, color = "black") +  # Confidence intervals
geom_point(aes(color = category), size = pt.size) +                                   # OR points, colored by category
scale_color_manual(
values = c(
"Pval < 0.05" = "#870052",
"Pval > 0.05" = "#4682B4"
),
name = "Category"
) +
geom_text(
aes(label = sprintf("%.2f [%.2f, %.2f]", OR, `2.5 %`, `97.5 %`)),  # Format: OR [2.5%, 97.5%]
hjust = -0.1, vjust = -0.7,
color = "gray40", size = or.label.size
) +
# Add a vertical line at OR = 1 for reference
geom_vline(xintercept = 1, color = "gray40", linetype = "dashed", size = 0.8) +
# Add minimal theme with border and grid lines
theme_classic() +
theme(
panel.border = element_rect(color = "black", fill = NA, size = 0.5),  # Border around plot
#panel.grid.major.x = element_line(color = "gray80", linetype = "dashed"),  # Dashed vertical grid lines
panel.grid.major.y = element_blank(),                                     # Remove horizontal grid lines
legend.position = "right",
legend.text = element_text(size = y.axis.text.size - 2),
legend.title = element_text(size = y.axis.text.size),
plot.title = element_text(hjust = 0.5),
plot.caption = element_text(hjust = 0.5),
axis.text.y = element_text(size = y.axis.text.size),
axis.text.x = element_text(size = x.axis.text.size, angle = 45)
) +
# Adjust x-axis limits based on user-defined parameters
#coord_cartesian(xlim = c(xlim_min, xlim_max))
scale_x_continuous(
limits = c(xlim_min, xlim_max),
breaks = seq(xlim_min, xlim_max, by = 1)#,  # Generate default breaks
)
if (add_xylabs){
forest = forest + labs(
x = "Odds Ratio (OR)",
y = "Variable",
title = plot_title,
caption = "Confidence intervals represent 95% CI"
)
} else {
forest = forest + labs(
x = "",
y = "",
title = "")
}
return(forest)
}
class(False)
class(FALSE)
make_forest_plot <- function(results_df, clinical_manifestation, outcome_var_colname, adjust_vars,
clinical_manifestation_colname = "clinical_manifestation", ntop = NULL,
pt.size = 2, y.axis.text.size, x.axis.text.size, or.label.size, plot_title = "",
name_mapping = NULL, add_xylabs = FALSE,
filter_sig_OR = TRUE) {
# Filter results to remove intercepts and adjust variables.
if (length(adjust_vars) == 1 && grepl("\\+", adjust_vars)) {
adjust_vars <- unlist(strsplit(adjust_vars, "\\+"))
adjust_vars <- trimws(adjust_vars)
}
if (filter_sig_OR){
print("Adjusted variables to be removed:")
print(adjust_vars)
results_df <- results_df %>%
filter(`2.5 %` < 1 & `97.5 %` < 1 | `2.5 %` > 1 & `97.5 %` > 1) %>%
filter(predictor != "(Intercept)") %>%
filter(!str_detect(predictor, paste(adjust_vars, collapse = "|")))
}
if (!is.null(ntop)){
# Select top results
top_results <- results_df[0:ntop, ] %>%
arrange(-OR)
} else {
top_results <- results_df
}
# Categorize results
top_results$category <- with(top_results, ifelse(`Pr>|z|` < 0.05, "Pval < 0.05", "Pval > 0.05"))
# Map names if provided by user
if (!is.null(name_mapping)) {
clinical_manifestation <- sapply(clinical_manifestation, function(col) name_mapping[[col]] %||% col)
# Rename clinical manifestation
top_results[[clinical_manifestation_colname]] <- sapply(top_results[[clinical_manifestation_colname]], function(clin) name_mapping[[clin]] %||% clin)
}
# Adjust x max and min limits for the plot.
xlim_min <- min(top_results[["2.5 %"]][is.finite(top_results[["2.5 %"]])], na.rm = TRUE) - 0.5
xlim_max <- max(top_results[["97.5 %"]][is.finite(top_results[["97.5 %"]])], na.rm = TRUE) + 0.5
break_sizes <- (xlim_max - xlim_min) / 10
# Forest plot
forest <- ggplot(top_results, aes(x = OR, y = reorder(paste(clinical_manifestation, .data[[outcome_var_colname]], predictor, sep = " - "), OR))) +
geom_errorbarh(aes(xmin = `2.5 %`, xmax = `97.5 %`), height = 0.2, color = "black") +  # Confidence intervals
geom_point(aes(color = `Pr>|z|`, shape = category), size = pt.size, ) +                                   # OR points, colored by category
scale_color_gradient(
low = ki_colors(color_palette = "functional")["1_dark_plum-text"],
high = ki_colors(color_palette = "functional")["3_blue"],
name = "Adj P-value"
) +
#scale_color_manual(
#  values = c(
#    "Pval < 0.05" = "#870052",
#    "Pval > 0.05" = "#4682B4"
#  ),
#  name = "Category"
#) +
geom_text(
aes(label = sprintf("%.2f [%.2f, %.2f]", OR, `2.5 %`, `97.5 %`)),  # Format: OR [2.5%, 97.5%]
hjust = -0.1, vjust = -0.7,
color = "gray40", size = or.label.size
) +
# Add a vertical line at OR = 1 for reference
geom_vline(xintercept = 1, color = "gray40", linetype = "dashed", size = 0.8) +
# Add minimal theme with border and grid lines
theme_classic() +
theme(
panel.border = element_rect(color = "black", fill = NA, size = 0.5),  # Border around plot
#panel.grid.major.x = element_line(color = "gray80", linetype = "dashed"),  # Dashed vertical grid lines
panel.grid.major.y = element_blank(),                                     # Remove horizontal grid lines
legend.position = "right",
legend.text = element_text(size = y.axis.text.size - 2),
legend.title = element_text(size = y.axis.text.size),
plot.title = element_text(hjust = 0.5),
plot.caption = element_text(hjust = 0.5),
axis.text.y = element_text(size = y.axis.text.size),
axis.text.x = element_text(size = x.axis.text.size, angle = 45)
) +
# Adjust x-axis limits based on user-defined parameters
#coord_cartesian(xlim = c(xlim_min, xlim_max))
scale_x_continuous(
limits = c(xlim_min, xlim_max),
breaks = seq(xlim_min, xlim_max, by = break_sizes),#,  # Generate default breaks
labels = function(x) sprintf("%.2f", x)
)
if (add_xylabs){
forest = forest + labs(
x = "Odds Ratio (OR)",
y = "Variable",
title = plot_title,
caption = "Confidence intervals represent 95% CI"
)
} else {
forest = forest + labs(
x = "",
y = "",
title = "")
}
return(forest)
}
help(ConsensusClustering)
help(ConsensusClusterPLus)
help(ConsensusClusterPlus)
??ConsensusClusterPlus
split("pam_euclidean", "_")
strsplit("pam_euclidean", "_")
strsplit("pam_euclidean", "_")[[1]]
ggsave(plot = stability_plot, filename = sprintf("BootstrapStability_n%s_5s.jpeg", nclust, plots_suffix), path = file.path(plot_dir, paste0("bootstrap_stability_results_", plots_suffix)))
ggsave(plot = sillplot, filename = sprintf("sillplot_n%s_%s.jpeg", ndim, plots_suffix), path = file.path(plots_dir, "clust_eval_results", paste0("silhouette_results_", plots_suffix)))
